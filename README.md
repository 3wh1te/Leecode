## Intro
### 1.
### 4.Median of Two Sorted Arrays（分而治之）

#### 解题思路：（关键问题在于边界的处理）

##### 自己的思路：

1. 取两个列表的中位数
2. 比较中位数大小
3. 大中位数舍去后面的部分，小的中位数舍去前面的部分，舍去的长度=短数组的中位数位置
4. 形成的新数组再进行如此操作
5. 终止条件：这个地方要考虑很多，比较复杂

##### 官方思路：

- 递归解法（简述一下思路）

  ​	首先要明确中位数的概念，也就是说该值左右两边的值的数量是一样的（当偶数的时候是中间两个值的平均值），所以前提条件就是要保证该值左右两边的值的数量相同，如何保证？
  $$
  假设 n>=m， i = 0 \sim m, j = \frac{m + n + 1}{2} - i ，有B[j−1]≤A[i] 且 \text{A}[i-1] \leq \text{B}[j]
  $$
  在次前提下，通过二分搜索搜索合适的i，直到找到满足条件的i，j为止，如果m+n为奇数：返回	max(A[*i*−1],B[*j*−1])，如果m+n为偶数：返回max(A[*i*−1],B[*j*−1])+min(A[*i*],B[*j*])/2。

  一共有三种情况：

  1. (j = 0 or i = m or B[j-1] <= A[i]) and (j = n or i = 0 or A[i-1] <= B[j]),条件满足，可以返回。（其中有一个边界值的情况下，就不用检查其中一个条件了）
  2. i > 0 且 j < n 的情况下，检查A[i-1] <= B[j]，证 i > 0 时 j < n，不满足 i 的范围往上加
  3. j > 0 且 i < m 的情况下，检查B[j-1] <= A[i]，证 j > 0 时 i < m，不满足 i 的范围往下减

  

  ### 5. Longest Palindromic Substring（DP）

  #### 解题思路

  ##### 自己的思路：（感觉自己思路简单一点）

  对于字符串中的一个字符：判断该字符是否为最长的回文开头，判断以该字符开头结尾的字符串是否为回文。如果是，更新最长回文，如果不是找下一个字符。

  ##### 官方思路：

  1. 暴力破解：不多叙述，复杂度*O*(*n*3)

  2. 动态规划：因为有 *P*(*i*,*j*)是回文，那么(*P*(*i*+1,*j*−1)是回文且*S*[i]*==*S*[j]*，所以对于字符串中的每一个字符，都可以以当前字符或与下一个字符一起为整个回文中心，扩展为更长的回文。

     也就是说对于单个字符P[i]来说肯定是回文，如果S[i] = S[i+1]，P[i,i+1]也是回文。对于每个字符都只有这两种情况成为回文中心，所以以这两种情况进行扩展，找到最长的回文。扩展方式就是如果P[i,j]是回文，下一次扩展就是P[i+1,j+1]。类似于扩散的感觉。

  